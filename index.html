<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Chart Game</title>

  <!-- Telegram + TonConnect -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://unpkg.com/@tonconnect/ui@2.3.0/dist/tonconnect-ui.min.js"></script>

  <!-- ✅ Lightweight Charts v4 (фикс под addAreaSeries) -->
  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
  <script>
    (function(){
      function loadFallback(){
        var s = document.createElement("script");
        s.src = "https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js";
        s.async = true;
        document.head.appendChild(s);
      }
      setTimeout(function(){
        if (!window.LightweightCharts) loadFallback();
      }, 1200);
    })();
  </script>

  <style>
    :root{
      --stroke:rgba(255,255,255,.10);
      --text:#f2efff;
      --muted:rgba(242,239,255,.65);
      --green:#31d17c;
      --red:#ff4d4d;
      --purple:#7c4dff;
      --orange:#ff9d2e;
      --shadow: 0 16px 60px rgba(0,0,0,.55);
      --radius: 16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1200px 600px at 60% 10%, rgba(124,77,255,.28), transparent 55%),
        radial-gradient(900px 520px at 20% 30%, rgba(49,209,124,.12), transparent 55%),
        radial-gradient(900px 520px at 85% 55%, rgba(255,77,77,.10), transparent 60%),
        linear-gradient(180deg, #070410, #0b0614 55%, #070410);
      color:var(--text);
      overflow-x:hidden;
    }
    .wrap{max-width:1040px;margin:0 auto;padding:12px 12px 22px;}

    .topbar{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position: sticky; top: 10px; z-index: 50;
      backdrop-filter: blur(10px);
    }
    .brand{display:flex;align-items:center;gap:10px;}
    .logo{
      width:34px;height:34px;border-radius:12px;
      background: radial-gradient(circle at 30% 30%, rgba(124,77,255,.9), rgba(124,77,255,.25)),
                  radial-gradient(circle at 70% 70%, rgba(49,209,124,.65), rgba(49,209,124,.05));
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 10px 25px rgba(124,77,255,.25);
    }
    .rightbar{display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:flex-end;}

    .btn{
      appearance:none;border:none;cursor:pointer;
      border-radius:12px;padding:10px 12px;
      font-weight:900;font-size:12px;letter-spacing:.2px;
      color:var(--text);
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      transition: transform .06s ease, background .2s ease, opacity .2s ease;
      display:inline-flex;align-items:center;gap:8px;white-space:nowrap;
    }
    .btn:active{transform: translateY(1px) scale(.99)}
    .btn.primary{
      background: linear-gradient(180deg, rgba(124,77,255,.95), rgba(124,77,255,.55));
      border:1px solid rgba(124,77,255,.75);
      box-shadow: 0 12px 30px rgba(124,77,255,.22);
    }
    .btn.orange{
      background: linear-gradient(180deg, rgba(255,157,46,.95), rgba(255,157,46,.55));
      border:1px solid rgba(255,157,46,.75);
      box-shadow: 0 12px 30px rgba(255,157,46,.20);
    }
    .btn.ghost{background: rgba(0,0,0,.18);}
    .btn.disabled{opacity:.45; pointer-events:none;}
    .tonIcon{width:18px;height:18px;object-fit:contain;display:block;filter: drop-shadow(0 6px 14px rgba(0,0,0,.35));}
    .mono{font-variant-numeric: tabular-nums; font-feature-settings:"tnum" 1;}

    .grid{margin-top:12px;display:grid;grid-template-columns:1.2fr .8fr;gap:12px;}
    @media (max-width:860px){ .grid{grid-template-columns:1fr} .topbar{position:static} }

    .card{
      border-radius: var(--radius);
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
      overflow:hidden;
      position: relative;
    }

    #chart{
      height:360px;
      background: radial-gradient(900px 520px at 50% 0%, rgba(124,77,255,.30), rgba(124,77,255,.08) 45%, rgba(0,0,0,.10) 70%);
      position: relative;
    }

    /* ✅ шарик на конце линии (HTML overlay) */
    .endOrb{
      position:absolute;
      width:12px;height:12px;border-radius:999px;
      background: rgba(255,255,255,.92);
      transform: translate(-50%,-50%);
      pointer-events:none;
      z-index: 22;
      box-shadow:
        0 0 0 2px rgba(255,255,255,.28),
        0 0 18px rgba(255,255,255,.45),
        0 0 38px rgba(124,77,255,.22);
      filter: drop-shadow(0 12px 26px rgba(0,0,0,.55));
      display:none;
    }
    .endOrb::before{
      content:"";
      position:absolute; inset:-10px;
      border-radius:999px;
      background: radial-gradient(circle, rgba(255,255,255,.18), transparent 60%);
      animation: orbPulse 1.15s ease-in-out infinite;
    }
    .endOrb::after{
      content:"";
      position:absolute; inset:-18px;
      border-radius:999px;
      background:
        radial-gradient(circle at 25% 35%, rgba(255,255,255,.18), transparent 45%),
        radial-gradient(circle at 70% 65%, rgba(255,255,255,.10), transparent 52%),
        radial-gradient(circle at 55% 25%, rgba(255,255,255,.08), transparent 48%);
      opacity:.65;
      filter: blur(0.2px);
      animation: orbSpray 1.8s linear infinite;
    }
    @keyframes orbPulse{
      0%,100%{ transform: scale(0.85); opacity:.55; }
      50%{ transform: scale(1.05); opacity:.85; }
    }
    @keyframes orbSpray{
      0%{ transform: rotate(0deg); opacity:.55; }
      50%{ transform: rotate(180deg); opacity:.80; }
      100%{ transform: rotate(360deg); opacity:.55; }
    }

    .chartError{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:16px;
      background: rgba(0,0,0,.25);
      backdrop-filter: blur(8px);
      z-index: 60;
    }
    .chartErrorBox{
      width:min(640px, 100%);
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      border-radius: 16px;
      padding:14px 14px;
      box-shadow: 0 18px 45px rgba(0,0,0,.45);
      color: rgba(242,239,255,.92);
      font-weight: 900;
      line-height: 1.35;
      font-size: 13px;
    }
    .chartErrorBox small{display:block; margin-top:8px; font-weight:800; opacity:.75}

    /* Countdown overlay */
    .countdown{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%,-50%);
      width: 112px;
      height: 112px;
      display:none;
      place-items:center;
      z-index: 20;
      pointer-events:none;
      filter: drop-shadow(0 18px 45px rgba(0,0,0,.55));
    }
    .countdown.show{display:grid;}
    .cdNum{
      position:absolute;
      font-weight:1200;
      font-size:34px;
      letter-spacing:.2px;
      color: var(--text);
      text-shadow: 0 8px 30px rgba(0,0,0,.65);
    }
    .cdSub{
      position:absolute;
      bottom: 18px;
      font-size: 10px;
      color: rgba(242,239,255,.70);
      font-weight: 900;
      letter-spacing: .25px;
      text-transform: uppercase;
    }

    .historyWrap{
      position:absolute;
      left:14px;
      bottom:14px;
      z-index: 25;
      display:flex;
      align-items:flex-end;
      gap:10px;
      pointer-events:none;
    }
    .histRow{
      display:flex;
      gap:6px;
      padding:8px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      backdrop-filter: blur(6px);
      box-shadow: 0 14px 35px rgba(0,0,0,.35);
      max-width: 520px;
      overflow:hidden;
    }
    .histItem{
      display:flex;
      align-items:center;
      gap:4px;
      font-weight:1000;
      font-size:11px;
      color: rgba(242,239,255,.92);
      white-space:nowrap;
    }
    .tri{
      width: 0; height: 0;
      border-left: 7px solid transparent;
      border-right: 7px solid transparent;
      position: relative;
      filter: drop-shadow(0 8px 18px rgba(0,0,0,.35));
    }
    .tri.up{ border-bottom: 12px solid var(--green); }
    .tri.down{ border-top: 12px solid var(--red); }
    .tri::after{
      content:"";
      position:absolute;
      left:-5px;
      width:0;height:0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
    }
    .tri.up::after{ top:2px; border-bottom: 9px solid rgba(255,255,255,.92); }
    .tri.down::after{ top:-11px; border-top: 9px solid rgba(255,255,255,.92); }
    .pctText{ min-width: 42px; text-align:right; }

    .toast{
      position:absolute;
      right:14px;
      bottom:14px;
      z-index: 30;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      backdrop-filter: blur(8px);
      font-weight:1100;
      font-size:12px;
      display:none;
      pointer-events:none;
      box-shadow: 0 18px 45px rgba(0,0,0,.45);
    }
    .toast.show{display:block;}
    .toast.win{border-color: rgba(49,209,124,.35);}
    .toast.lose{border-color: rgba(255,77,77,.35);}

    .betWrap{padding:12px;}
    .amountGrid{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:10px;}
    .chip{
      padding:10px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);color:var(--text);font-weight:1000;font-size:12px;
      cursor:pointer;text-align:center;user-select:none;
    }
    .chip.active{
      border-color: rgba(255,157,46,.65);
      background: linear-gradient(180deg, rgba(255,157,46,.18), rgba(0,0,0,.18));
      box-shadow: 0 10px 25px rgba(255,157,46,.10);
    }
    .bigBox{
      padding:12px;border-radius:16px;border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);margin-bottom:10px;
    }
    .bigBox .label{font-size:11px;color:var(--muted);font-weight:900;text-transform:uppercase;letter-spacing:.25px}
    .bigBox .value{font-size:18px;font-weight:1150;margin-top:6px}

    .actions{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;}
    .btnLong{
      background: linear-gradient(180deg, rgba(49,209,124,.95), rgba(49,209,124,.50));
      border:1px solid rgba(49,209,124,.70);
      box-shadow: 0 14px 34px rgba(49,209,124,.18);
    }
    .btnShort{
      background: linear-gradient(180deg, rgba(255,77,77,.95), rgba(255,77,77,.50));
      border:1px solid rgba(255,77,77,.70);
      box-shadow: 0 14px 34px rgba(255,77,77,.18);
    }
    .hint{margin-top:10px;font-size:12px;color:var(--muted);line-height:1.35;min-height:34px;}

    .bonusOverlay{
      position: fixed; inset: 0; background: rgba(0,0,0,.62);
      display:none;align-items:flex-end;justify-content:center;padding:14px;
      z-index:200;backdrop-filter: blur(8px);
    }
    .bonusSheet{
      width: min(560px, 100%);
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.22));
      box-shadow: 0 26px 90px rgba(0,0,0,.65);
      overflow:hidden;
    }
    .bonusHead{
      padding: 12px 12px 10px;display:flex;align-items:center;justify-content:space-between;
      border-bottom:1px solid rgba(255,255,255,.08);background: rgba(0,0,0,.18);
    }
    .bonusHead .t{font-weight:1100;letter-spacing:.3px;text-transform:uppercase;font-size:12px;color:var(--text);}
    .bonusBody{padding:12px;color:var(--muted);line-height:1.45;font-size:13px;}

    .modalOverlay{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      display:none;
      align-items:flex-end;
      justify-content:center;
      z-index:220;
      padding:14px;
    }
    .modalOverlay.open{ display:flex; }
    .sheet{
      width:min(560px, 100%);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(0,0,0,.22));
      box-shadow: 0 26px 90px rgba(0,0,0,.65);
      overflow:hidden;
    }
    .sheetHeader{
      padding:12px;
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    .sheetTitle{display:flex;align-items:center;gap:10px;font-weight:1100;letter-spacing:.3px;text-transform:uppercase;font-size:12px;}
    .sheetTitle img{width:22px;height:22px;border-radius:8px;}
    .closeBtn{
      width:42px;height:42px;border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: var(--text);
      cursor:pointer;font-weight:1100;
    }
    .sheetBtns{padding:12px;display:flex;flex-direction:column;gap:10px;}
    .sheetAction{
      height:54px;border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      box-shadow: 0 12px 26px rgba(0,0,0,.18);
      display:flex;align-items:center;justify-content:space-between;
      padding:0 14px;
      cursor:pointer;user-select:none;
      font-weight:1000;color:var(--text);
    }
    .sheetAction small{color:var(--muted);font-weight:900;}
    .depositInput{
      width:100%;height:52px;border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: var(--text);
      padding:0 14px;
      font-size:18px;font-weight:1000;
      outline:none;
    }
    .row2{display:flex;gap:10px;margin-top:12px;}
    .row2 .sheetAction{flex:1 1 0;justify-content:center;}

    a[href*="tradingview"], a[href*="TradingView"]{display:none!important;}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand"><div class="logo"></div></div>

      <div class="rightbar">
        <button class="btn ghost" id="btnBonus">BONUS</button>
        <button class="btn orange" id="btnTopup">Пополнить</button>

        <button class="btn primary" id="btnBalance">
          <img class="tonIcon" src="/ton.png" alt="TON" />
          <span>Баланс:</span>
          <span class="mono" id="balTon">0.00</span>
        </button>
      </div>
    </div>

    <div class="grid">
      <div class="card" id="chartCard">
        <div id="chart">
          <div class="endOrb" id="endOrb"></div>
        </div>

        <div class="countdown" id="countdown">
          <svg width="112" height="112" viewBox="0 0 112 112">
            <defs>
              <filter id="glow">
                <feGaussianBlur stdDeviation="3.5" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            <circle cx="56" cy="56" r="46" stroke="rgba(255,255,255,.10)" stroke-width="10" fill="rgba(0,0,0,.20)"></circle>
            <circle id="cdRing" cx="56" cy="56" r="46" stroke="rgba(49,209,124,.95)" stroke-width="10" fill="transparent"
              stroke-linecap="round" transform="rotate(-90 56 56)"
              filter="url(#glow)"></circle>
          </svg>
          <div class="cdNum mono" id="cdNum">7</div>
          <div class="cdSub">BET</div>
        </div>

        <div class="historyWrap">
          <div class="histRow" id="histRow"></div>
        </div>

        <div class="toast" id="toast"></div>
      </div>

      <div class="card">
        <div class="betWrap">
          <div class="amountGrid" id="chips">
            <div class="chip active" data-amt="0.1">0.10</div>
            <div class="chip" data-amt="0.2">0.20</div>
            <div class="chip" data-amt="0.5">0.50</div>
            <div class="chip" data-amt="1">1.00</div>
            <div class="chip" data-amt="2">2.00</div>
            <div class="chip" data-amt="5">5.00</div>
            <div class="chip" data-amt="10">10</div>
            <div class="chip" data-amt="20">20</div>
          </div>

          <div class="bigBox">
            <div class="label">Bet amount</div>
            <div class="value"><span class="mono" id="betAmt">0.10</span> TON</div>
          </div>

          <div class="bigBox">
            <div class="label">Your position</div>
            <div class="value mono" id="posStatus">—</div>
          </div>

          <div class="actions">
            <button class="btn btnLong" id="btnLong">LONG ▲</button>
            <button class="btn btnShort" id="btnShort">SHORT ▼</button>
          </div>

          <div class="hint" id="hint"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="bonusOverlay" id="bonusOverlay">
    <div class="bonusSheet">
      <div class="bonusHead">
        <div class="t">BONUS</div>
        <button class="btn ghost" id="btnBonusClose">Закрыть</button>
      </div>
      <div class="bonusBody">Тут будет бонусная система. Функцию добавим позже.</div>
    </div>
  </div>

  <div class="modalOverlay" id="tonModal">
    <div class="sheet">
      <div class="sheetHeader">
        <div class="sheetTitle"><img src="/ton.png" alt="TON"> TON</div>
        <button class="closeBtn" id="tonClose">✕</button>
      </div>

      <div class="sheetBtns">
        <div class="sheetAction" id="actionBind">
          <span>Привязать кошелёк</span>
          <small id="walletStatus">Not connected</small>
        </div>
        <div class="sheetAction" id="actionDisconnect">
          <span>Отвязать кошелёк</span>
          <small>Disconnect</small>
        </div>
        <div class="sheetAction" id="actionDeposit">
          <span>Депозит</span>
          <small>Enter amount</small>
        </div>
        <div class="sheetAction" id="actionWithdraw">
          <span>Вывод</span>
          <small>Later</small>
        </div>
      </div>
    </div>
  </div>

  <div class="modalOverlay" id="depositModal">
    <div class="sheet">
      <div class="sheetHeader">
        <div class="sheetTitle">Пополнение</div>
        <button class="closeBtn" id="depositClose">✕</button>
      </div>

      <div style="padding:12px;">
        <input id="depositAmount" class="depositInput" type="number" min="0.1" step="0.1" placeholder="Сколько TON пополнить?">

        <div class="row2">
          <div class="sheetAction" id="depositBack">Назад</div>
          <div class="sheetAction" id="depositConfirm">Подтвердить</div>
        </div>

        <div class="hint" id="depositHint" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>

<script>
(function(){
  const $ = (id) => document.getElementById(id);

  function showChartError(message){
    const card = $("chartCard");
    if(!card) return;
    const old = card.querySelector(".chartError");
    if(old) old.remove();
    const overlay = document.createElement("div");
    overlay.className = "chartError";
    overlay.innerHTML = `
      <div class="chartErrorBox">
        Ошибка графика: ${String(message || "unknown")}
        <small>Проверь Network: lightweight-charts@4.2.0 + /api/state + /api/series</small>
      </div>
    `;
    card.appendChild(overlay);
  }
  function clearChartError(){
    const card = $("chartCard");
    if(!card) return;
    const old = card.querySelector(".chartError");
    if(old) old.remove();
  }

  function waitForLW(cb){
    let tries = 0;
    const t = setInterval(() => {
      if (window.LightweightCharts && window.LightweightCharts.createChart){
        clearInterval(t);
        cb();
        return;
      }
      tries++;
      if (tries > 40){
        clearInterval(t);
        showChartError("LightweightCharts не загрузился (CDN блок/сеть).");
      }
    }, 150);
  }

  window.addEventListener("load", () => {
    const tg = window.Telegram?.WebApp;
    try { tg?.ready?.(); tg?.expand?.(); } catch {}

    const API_BASE = window.API_BASE || location.origin;
    const apiUrl = (path) => new URL(path, API_BASE).toString();

    async function apiGet(path){
      const r = await fetch(apiUrl(path), { cache: "no-store" });
      const txt = await r.text();
      let j = null;
      try{ j = JSON.parse(txt); }catch{ j = { raw: txt }; }
      if(!r.ok){
        console.error("API GET FAIL:", path, r.status, j);
        throw new Error(path + " " + r.status);
      }
      return j;
    }
    async function apiPost(path, body){
      const r = await fetch(apiUrl(path), {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body || {})
      });
      const txt = await r.text();
      let j = null;
      try{ j = JSON.parse(txt); }catch{ j = { raw: txt }; }
      if(!r.ok){
        console.error("API POST FAIL:", path, r.status, j);
        throw new Error(path + " " + r.status);
      }
      return j;
    }

    // =========================
    // CHART (smooth + scale fixes + orb)
    // =========================
    let chart = null;
    let area = null;
    let bound = null;

    const endOrb = $("endOrb");
    const CHART_H = 360;

    // ✅ фиксированный диапазон
    const MIN_Y = -100;
    const MAX_Y = 200;

    // ✅ цвета серии: зелёный/красный
    function applySeriesColorByValue(v){
      const isGreen = (Number(v) >= 0);
      const line = isGreen ? "rgba(49,209,124,.95)" : "rgba(255,77,77,.95)";
      const top  = isGreen ? "rgba(49,209,124,.26)" : "rgba(255,77,77,.22)";
      const bot  = "rgba(0,0,0,0)";
      try{ area.applyOptions({ lineColor: line, topColor: top, bottomColor: bot }); }catch{}
    }

    // ✅ чтобы шкала была только цифры, без “белых плашек” (плашки были от priceLines axisLabel)
    function addLevelLine(v){
      // горизонтальная линия без подписи на оси
      return area.createPriceLine({
        price: v,
        color: "rgba(255,255,255,.10)",
        lineWidth: 1,
        lineStyle: LightweightCharts.LineStyle.Dotted,
        axisLabelVisible: false,
        title: ""
      });
    }

    function normalizeTsToSec(ts){
      const n = Number(ts);
      if(!Number.isFinite(n)) return Math.floor(Date.now()/1000);
      if(n > 2e12) return Math.floor(n/1000);
      if(n > 2e10) return Math.floor(n/1000);
      return Math.floor(n);
    }

    // backend отдаёт [[ts,value],...]
    function toChartData(seriesArr){
      const arr = Array.isArray(seriesArr) ? seriesArr : [];
      return arr
        .map(([ts, val]) => ({ time: normalizeTsToSec(ts), value: Number(val) }))
        .filter(p => Number.isFinite(p.time) && Number.isFinite(p.value))
        .sort((a,b) => a.time - b.time);
    }

    function initChart(){
      if(!window.LightweightCharts?.createChart){
        showChartError("LightweightCharts не загрузился");
        return false;
      }
      const el = $("chart");
      if(!el){ showChartError("Не найден #chart"); return false; }

      clearChartError();

      const W = Math.max(320, el.clientWidth || 900);
      chart = LightweightCharts.createChart(el, {
        width: W,
        height: CHART_H,
        layout: { background: { type:"solid", color:"transparent" }, textColor: "rgba(242,239,255,.70)" },
        grid: { vertLines: { color: "rgba(255,255,255,.05)" }, horzLines: { color: "rgba(255,255,255,.05)" } },
        rightPriceScale: {
          visible: true,
          borderColor: "rgba(255,255,255,.10)",
          textColor: "rgba(242,239,255,.55)",
          scaleMargins: { top: 0.10, bottom: 0.12 },
        },
        timeScale: {
          visible: true,
          borderColor: "rgba(255,255,255,.10)",
          timeVisible: true,
          secondsVisible: true,
        },
        crosshair: { vertLine: { color: "rgba(124,77,255,.35)" }, horzLine: { color: "rgba(124,77,255,.25)" } }
      });

      area = chart.addAreaSeries({
        lineWidth: 2,
        lineColor: "rgba(49,209,124,.95)",
        topColor: "rgba(49,209,124,.26)",
        bottomColor: "rgba(0,0,0,0)",
        priceFormat: { type:"custom", formatter: (v) => `${Math.round(Number(v))}%` }
      });

      // ✅ зафиксируем диапазон через “невидимую” bound-серию
      bound = chart.addLineSeries({
        color: "rgba(0,0,0,0)",
        lineWidth: 1,
        lastValueVisible: false,
        priceLineVisible: false,
      });
      const now = Math.floor(Date.now()/1000);
      bound.setData([{ time: now-2, value: MIN_Y }, { time: now-1, value: MAX_Y }]);

      // уровни без плашек
      addLevelLine(200);
      addLevelLine(150);
      addLevelLine(100);
      addLevelLine(50);
      addLevelLine(0);
      addLevelLine(-50);
      addLevelLine(-100);

      // ✅ fallback-нитка (чтобы всегда не пусто)
      area.setData([
        { time: now-6, value: 0 },
        { time: now-4, value: 3 },
        { time: now-2, value: -2 },
        { time: now, value: 1 }
      ]);
      applySeriesColorByValue(1);

      let fitted = false;

      const ro = new ResizeObserver(() => {
        try{
          const w = Math.max(320, el.clientWidth || 900);
          chart.resize(w, CHART_H);
          // чтобы orb не “улетал”
          scheduleOrbRecalc();
        }catch{}
      });
      ro.observe(el);

      // один раз fit
      setTimeout(() => {
        if(!fitted){
          try{ chart.timeScale().fitContent(); }catch{}
          fitted = true;
        }
      }, 50);

      return true;
    }

    // ✅ скрывать/показывать шкалы (во время приема ставок скрываем)
    function setScalesVisible(visible){
      if(!chart) return;
      try{
        chart.applyOptions({
          rightPriceScale: { visible: !!visible },
          timeScale: { visible: !!visible }
        });
      }catch{}
    }

    // =========================
    // ORB (шарик на конце)
    // =========================
    let lastOrbPoint = null;
    let orbRAF = 0;

    function placeOrbAtPoint(pt){
      if(!chart || !area || !endOrb || !pt) return;
      const x = chart.timeScale().timeToCoordinate(pt.time);
      const y = area.priceToCoordinate(pt.value);
      if (x == null || y == null) return;

      endOrb.style.left = x + "px";
      endOrb.style.top  = y + "px";
      endOrb.style.display = "block";
    }

    function scheduleOrbRecalc(){
      if(orbRAF) cancelAnimationFrame(orbRAF);
      orbRAF = requestAnimationFrame(() => {
        if(lastOrbPoint) placeOrbAtPoint(lastOrbPoint);
      });
    }

    // =========================
    // Smooth update logic
    // =========================
    let cached = [];             // что уже отрисовали
    let lastFitDone = false;
    let anim = { active:false, from:null, to:null, t0:0, dur:260 };

    function ensureBoundNow(){
      if(!bound) return;
      const now = Math.floor(Date.now()/1000);
      bound.setData([{ time: now-2, value: MIN_Y }, { time: now-1, value: MAX_Y }]);
    }

    function startTween(lastPoint, targetPoint){
      if(!lastPoint || !targetPoint) return;
      anim.active = true;
      anim.from = { ...lastPoint };
      anim.to = { ...targetPoint };
      anim.t0 = performance.now();
      tickTween();
    }

    function tickTween(){
      if(!anim.active || !area) return;
      const t = performance.now();
      const p = Math.min(1, (t - anim.t0) / anim.dur);
      const v = anim.from.value + (anim.to.value - anim.from.value) * (p * (2 - p)); // easeOutQuad
      area.update({ time: anim.to.time, value: v });
      applySeriesColorByValue(v);

      lastOrbPoint = { time: anim.to.time, value: v };
      scheduleOrbRecalc();

      if(p < 1){
        requestAnimationFrame(tickTween);
      } else {
        anim.active = false;
      }
    }

    // обновление без лагов:
    // - не делаем setData каждый раз
    // - добавляем только новые точки
    // - последнюю точку анимируем
    function applySeriesPoints(points){
      if(!chart || !area || !Array.isArray(points) || points.length === 0) return;

      ensureBoundNow();

      // первый раз — setData
      if(cached.length === 0){
        cached = points.slice(-600); // ограничим память
        area.setData(cached);
        const last = cached[cached.length-1];
        applySeriesColorByValue(last.value);
        lastOrbPoint = last;
        scheduleOrbRecalc();
        if(!lastFitDone){
          try{ chart.timeScale().fitContent(); }catch{}
          lastFitDone = true;
        }
        return;
      }

      const lastDrawn = cached[cached.length-1];
      const lastIncoming = points[points.length-1];

      // добавляем новые точки (кроме самой последней — её будем твинить)
      const newOnes = [];
      for (const p of points){
        if (p.time > lastDrawn.time) newOnes.push(p);
      }

      if(newOnes.length > 1){
        // все кроме последней — сразу update
        for (let i=0;i<newOnes.length-1;i++){
          const p = newOnes[i];
          area.update(p);
          cached.push(p);
        }
      }

      // последнюю точку — твиним, если она новая или обновилась
      const tgt = newOnes.length ? newOnes[newOnes.length-1] : null;

      if(tgt){
        const from = cached[cached.length-1];
        // подменим “последнюю” в кеше на конечную, но рисовать будем плавно
        cached.push(tgt);
        startTween(from, tgt);
      } else if(lastIncoming.time === lastDrawn.time && Number(lastIncoming.value) !== Number(lastDrawn.value)){
        // если сервер обновляет текущую секунду (редко) — тоже твиним
        cached[cached.length-1] = lastIncoming;
        startTween(lastDrawn, lastIncoming);
      }

      // чистим кеш
      if(cached.length > 800) cached = cached.slice(-650);
    }

    // =========================
    // Countdown
    // =========================
    const cdEl = $("countdown");
    const cdNumEl = $("cdNum");
    const cdRingEl = $("cdRing");

    const R = 46;
    const CIRC = 2 * Math.PI * R;
    if (cdRingEl){
      cdRingEl.setAttribute("stroke-dasharray", String(CIRC));
      cdRingEl.setAttribute("stroke-dashoffset", "0");
    }
    function setRing(progress01){
      if(!cdRingEl) return;
      const off = CIRC * (1 - Math.max(0, Math.min(1, progress01)));
      cdRingEl.setAttribute("stroke-dashoffset", String(off));
    }
    function setRingColor(secLeft){
      if(!cdRingEl) return;
      if (secLeft >= 5) cdRingEl.setAttribute("stroke", "rgba(49,209,124,.95)");
      else if (secLeft >= 3) cdRingEl.setAttribute("stroke", "rgba(255,204,51,.95)");
      else cdRingEl.setAttribute("stroke", "rgba(255,77,77,.95)");
    }

    // History
    function renderHistory(items){
      const row = $("histRow");
      if(!row) return;
      row.innerHTML = "";
      const arr = Array.isArray(items) ? items : [];
      for (const it of arr.slice(0, 12)) {
        const pct = Number(it.pct || 0);
        const wrap = document.createElement("div");
        wrap.className = "histItem";

        const tri = document.createElement("div");
        tri.className = "tri " + (pct >= 0 ? "up" : "down");

        const txt = document.createElement("div");
        txt.className = "pctText mono";
        txt.textContent = (pct > 0 ? "+" : "") + String(Math.round(pct)) + "%";

        wrap.appendChild(tri);
        wrap.appendChild(txt);
        row.appendChild(wrap);
      }
    }

    // Toast
    const toast = $("toast");
    let toastTimer = null;
    function showToast(kind, text){
      if(!toast) return;
      toast.className = "toast show " + (kind || "");
      toast.textContent = text;
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        toast.className = "toast";
        toast.textContent = "";
      }, 1500);
    }

    // BONUS
    const bonusOverlay = $("bonusOverlay");
    if ($("btnBonus")) $("btnBonus").onclick = () => bonusOverlay.style.display = "flex";
    if ($("btnBonusClose")) $("btnBonusClose").onclick = () => bonusOverlay.style.display = "none";
    if (bonusOverlay) bonusOverlay.addEventListener("click", (e) => {
      if(e.target === bonusOverlay) bonusOverlay.style.display = "none";
    });

    // Chips
    let selectedAmt = 0.10;
    if ($("chips")) {
      $("chips").addEventListener("click", (e) => {
        const chip = e.target.closest(".chip");
        if(!chip) return;
        document.querySelectorAll(".chip").forEach(c => c.classList.remove("active"));
        chip.classList.add("active");
        selectedAmt = Number(chip.dataset.amt || "0.1");
        if ($("betAmt")) $("betAmt").textContent = selectedAmt.toFixed(2);
      });
    }

    // =========================
    // Wallet (оставил как у тебя, без изменений по логике)
    // =========================
    let __tonCore = null;
    async function tonCore(){
      if (!__tonCore) __tonCore = await import("https://esm.sh/@ton/core@0.58.0");
      return __tonCore;
    }
    function bytesToBase64(bytes){
      let bin = "";
      for (const b of bytes) bin += String.fromCharCode(b);
      return btoa(bin);
    }
    async function commentToBocBase64(comment){
      const { beginCell } = await tonCore();
      const cell = beginCell().storeUint(0, 32).storeStringTail(String(comment || "")).endCell();
      const boc = cell.toBoc({ idx: false });
      return bytesToBase64(boc);
    }
    function shortAddr(a){ return a ? (a.slice(0,6) + "..." + a.slice(-6)) : ""; }

    function getWalletRawLS(){
      const ls = (localStorage.getItem("walletRaw") || "").trim();
      return ls || null;
    }
    async function setWalletFromTonConnect(wallet){
      const addr = (wallet?.account?.address || "").trim();
      if (!addr){
        localStorage.removeItem("walletRaw");
        localStorage.removeItem("walletFriendly");
        return;
      }
      const { Address } = await tonCore();
      const raw = Address.parse(addr).toRawString();
      localStorage.setItem("walletRaw", raw);
      const fr = Address.parse(raw).toString({ urlSafe: true, bounceable: false, testOnly: false });
      localStorage.setItem("walletFriendly", fr);
    }
    async function getWalletFriendlyLS(){
      const cached = (localStorage.getItem("walletFriendly") || "").trim();
      if (cached) return cached;
      const raw = getWalletRawLS();
      if (!raw) return null;
      const { Address } = await tonCore();
      const fr = Address.parse(raw).toString({ urlSafe: true, bounceable: false, testOnly: false });
      localStorage.setItem("walletFriendly", fr);
      return fr;
    }

    (function initTonConnect(){
      try{
        const TonConnectUI = window.TON_CONNECT_UI?.TonConnectUI;
        if (!TonConnectUI) { window.__tonUI = null; window.__wallet = null; return; }

        const tonUI = new TonConnectUI({
          manifestUrl: location.origin + "/tonconnect-manifest.json",
        });

        window.__tonUI = tonUI;
        window.__wallet = null;

        tonUI.onStatusChange(async (wallet) => {
          window.__wallet = wallet || null;
          try{ await setWalletFromTonConnect(wallet); }catch{
            localStorage.removeItem("walletRaw");
            localStorage.removeItem("walletFriendly");
          }
          window.dispatchEvent(new Event("wallet_changed"));
        });

        tonUI.connectionRestored
          .then(() => window.dispatchEvent(new Event("wallet_changed")))
          .catch(() => {});
      }catch{
        window.__tonUI = null;
        window.__wallet = null;
      }
    })();

    function setBalanceTonUI(v){
      const ton = Number(v) || 0;
      if ($("balTon")) $("balTon").textContent = ton.toFixed(2);
    }
    async function refreshBalance(){
      // демо: сервер может отдавать 0 если не реализовано
      const raw = getWalletRawLS();
      if (!raw){ setBalanceTonUI(0); return 0; }
      const r = await fetch(apiUrl(`/api/balance?address=${encodeURIComponent(raw)}&t=${Date.now()}`), { cache:"no-store" });
      const j = await r.json().catch(()=>({}));
      const ton = Number(j.balanceTon ?? j.ton ?? 0);
      if (Number.isFinite(ton)) setBalanceTonUI(ton);
      return ton;
    }

    // TON modals
    const tonModal = $("tonModal");
    const depositModal = $("depositModal");
    function openTonModal(){ tonModal?.classList.add("open"); }
    function closeTonModal(){ tonModal?.classList.remove("open"); }
    function openDepositModal(){ depositModal?.classList.add("open"); }
    function closeDepositModal(){ depositModal?.classList.remove("open"); }

    if ($("btnBalance")) $("btnBalance").onclick = () => openTonModal();
    if ($("tonClose")) $("tonClose").onclick = () => closeTonModal();
    tonModal?.addEventListener("click", (e) => { if(e.target === tonModal) closeTonModal(); });

    if ($("depositClose")) $("depositClose").onclick = () => closeDepositModal();
    if ($("depositBack")) $("depositBack").onclick = () => closeDepositModal();
    depositModal?.addEventListener("click", (e) => { if(e.target === depositModal) closeDepositModal(); });

    async function syncWalletUI(){
      const raw = getWalletRawLS();
      const walletStatus = $("walletStatus");
      if (!walletStatus) return;
      if (!raw){
        walletStatus.textContent = "Not connected";
        return;
      }
      const fr = await getWalletFriendlyLS();
      walletStatus.textContent = shortAddr(fr || raw);
    }

    window.addEventListener("wallet_changed", async () => {
      await syncWalletUI();
      await refreshBalance();
    });

    if ($("actionBind")) $("actionBind").onclick = async () => {
      if (window.__tonUI?.openModal) { await window.__tonUI.openModal(); return; }
      alert("TonConnect не загрузился или manifest не доступен.");
    };

    if ($("actionDisconnect")) $("actionDisconnect").onclick = async () => {
      try{ await window.__tonUI?.disconnect?.(); }catch{}
      localStorage.removeItem("walletRaw");
      localStorage.removeItem("walletFriendly");
      window.__wallet = null;
      await syncWalletUI();
      setBalanceTonUI(0);
      alert("Кошелёк отвязан.");
    };

    if ($("actionDeposit")) $("actionDeposit").onclick = async () => {
      if (!getWalletRawLS()){ alert("Сначала привяжи кошелёк."); return; }
      if ($("depositHint")) $("depositHint").textContent = "";
      openDepositModal();
    };

    if ($("actionWithdraw")) $("actionWithdraw").onclick = () => alert("Вывод добавим позже.");

    if ($("btnTopup")) $("btnTopup").onclick = async () => {
      if (!getWalletRawLS()){ openTonModal(); alert("Сначала привяжи кошелёк."); return; }
      if ($("depositHint")) $("depositHint").textContent = "";
      openDepositModal();
    };

    if ($("depositConfirm")) $("depositConfirm").onclick = async () => {
      alert("Депозит подключишь позже (серверная часть).");
    };

    // =========================
    // GAME STATE
    // =========================
    let currentRound = null;
    let betMs = 7000;
    let roundMs = 19000;
    let timeOffsetMs = 0;

    function serverNow(){ return Date.now() + timeOffsetMs; }

    // bet ui
    let pos = null;
    function setHint(text){ if ($("hint")) $("hint").textContent = text || ""; }
    function setPosStatus(){
      if(!$("posStatus")) return;
      if(!pos){ $("posStatus").textContent = "—"; return; }
      $("posStatus").textContent = `${pos.side.toUpperCase()} • ${pos.amount.toFixed(2)} TON`;
    }

    let bettingOpen = false;
    function setButtonsEnabled(on){
      const b1 = $("btnLong");
      const b2 = $("btnShort");
      if(!b1 || !b2) return;
      if (on){
        b1.classList.remove("disabled");
        b2.classList.remove("disabled");
        bettingOpen = true;
      } else {
        b1.classList.add("disabled");
        b2.classList.add("disabled");
        bettingOpen = false;
      }
    }

    async function place(side){
      if(!bettingOpen) return;
      const raw = getWalletRawLS() || "guest";
      try{
        await apiPost("/api/bet_place?t=" + Date.now(), {
          side,
          amountTon: selectedAmt,
          roundId: currentRound?.roundId,
          address: raw
        });
        pos = { side, amount: selectedAmt, roundId: currentRound.roundId };
        setPosStatus();
        setHint("Ставка принята");
      }catch(e){
        setHint("Ошибка ставки");
      }
    }

    if ($("btnLong")) $("btnLong").onclick = () => place("long");
    if ($("btnShort")) $("btnShort").onclick = () => place("short");

    let lastSettledRound = null;
    async function trySettleIfNeeded(){
      if(!pos || !currentRound) return;

      const nowS = serverNow();
      const finishAt = currentRound.nextAt;
      if (nowS < finishAt) return;
      if (lastSettledRound === pos.roundId) return;

      const raw = getWalletRawLS() || "guest";
      try{
        const r = await apiPost("/api/bet_settle?t=" + Date.now(), {
          address: raw,
          roundId: pos.roundId
        });
        if (r?.status === "pending") return;

        lastSettledRound = pos.roundId;

        const pct = Number(r.pct);
        const sPct = (pct > 0 ? "+" : "") + String(Math.round(pct)) + "%";
        const profit = Number(r.profitTon || 0);

        if (profit >= 0) showToast("win", `WIN ${sPct}`);
        else showToast("lose", `LOSE ${sPct}`);

        pos = null;
        setPosStatus();
        setHint("");
      }catch(e){}
    }

    // ✅ во время приема ставок скрываем шкалу; когда ставок нет — показываем
    let prevScaleMode = null; // "hide"|"show"
    function updateBetCountdown(){
      if(!currentRound || !cdEl || !cdNumEl) return;

      const nowS = serverNow();
      const startAt = currentRound.startAt;
      const endAt = currentRound.endAt;

      const inBet = (nowS >= startAt && nowS < endAt);

      if (inBet){
        const leftMs = endAt - nowS;
        const secLeft = Math.max(0, Math.ceil(leftMs/1000));

        cdEl.classList.add("show");
        cdNumEl.textContent = String(secLeft);

        const progress = leftMs / betMs;
        setRing(progress);
        setRingColor(secLeft);

        setButtonsEnabled(true);

        if(prevScaleMode !== "hide"){
          setScalesVisible(false);
          prevScaleMode = "hide";
        }
      } else {
        cdEl.classList.remove("show");
        setButtonsEnabled(false);

        // показываем шкалу в “торговле” (когда график снова идёт)
        if(prevScaleMode !== "show"){
          setScalesVisible(true);
          prevScaleMode = "show";
        }
      }
    }

    async function loadState(){
      const data = await apiGet("/api/state?t=" + Date.now());
      timeOffsetMs = (data.serverNow || Date.now()) - Date.now();
      currentRound = data.round;
      betMs = data.betMs || 7000;
      roundMs = data.roundMs || 19000;
      renderHistory(data.history || []);
    }

    // ✅ серии грузим часто, но применяем дёшево (update + tween)
    async function loadSeries(){
      const data = await apiGet("/api/series?t=" + Date.now());
      const points = toChartData(data.series);
      if(!points.length) return;
      applySeriesPoints(points);
      clearChartError();
    }

    // BOOT
    setPosStatus();
    setHint("");
    setButtonsEnabled(false);

    waitForLW(() => {
      const ok = initChart();
      if(!ok) return;

      (async function boot(){
        try{
          await loadState().catch(e => console.warn("state err", e));
          await loadSeries().catch(e => console.warn("series err", e));
          await syncWalletUI().catch(()=>{});
          await refreshBalance().catch(()=>{});
        }catch(e){
          console.error("BOOT ERROR:", e);
        }
      })();

      // ✅ интервалы легче: state редко, series часто но лёгкое
      setInterval(() => loadState().catch(()=>{}), 900);
      setInterval(() => loadSeries().catch(()=>{}), 220); // плавнее “движение”
      setInterval(() => updateBetCountdown(), 120);
      setInterval(() => trySettleIfNeeded(), 500);
      setInterval(() => refreshBalance().catch(()=>{}), 6500);
    });
  });
})();
</script>
</body>
</html>
