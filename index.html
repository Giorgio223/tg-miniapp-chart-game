<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Chart Game</title>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://unpkg.com/@tonconnect/ui@2.3.0/dist/tonconnect-ui.min.js"></script>
  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    :root{
      --stroke:rgba(255,255,255,.10);
      --text:#f2efff;
      --muted:rgba(242,239,255,.65);
      --green:#31d17c;
      --red:#ff4d4d;
      --purple:#7c4dff;
      --orange:#ff9d2e;
      --shadow: 0 16px 60px rgba(0,0,0,.55);
      --radius: 16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1200px 600px at 60% 10%, rgba(124,77,255,.28), transparent 55%),
        radial-gradient(900px 520px at 20% 30%, rgba(49,209,124,.12), transparent 55%),
        radial-gradient(900px 520px at 85% 55%, rgba(255,77,77,.10), transparent 60%),
        linear-gradient(180deg, #070410, #0b0614 55%, #070410);
      color:var(--text);
      overflow-x:hidden;
    }
    .wrap{max-width:1040px;margin:0 auto;padding:12px 12px 22px;}
    .topbar{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position: sticky; top: 10px; z-index: 50;
      backdrop-filter: blur(10px);
    }
    .brand{display:flex;align-items:center;gap:10px;}
    .logo{
      width:34px;height:34px;border-radius:12px;
      background: radial-gradient(circle at 30% 30%, rgba(124,77,255,.9), rgba(124,77,255,.25)),
                  radial-gradient(circle at 70% 70%, rgba(49,209,124,.65), rgba(49,209,124,.05));
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 10px 25px rgba(124,77,255,.25);
    }
    .rightbar{display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:flex-end;}
    .btn{
      appearance:none;border:none;cursor:pointer;
      border-radius:12px;padding:10px 12px;
      font-weight:900;font-size:12px;letter-spacing:.2px;
      color:var(--text);
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      transition: transform .06s ease, background .2s ease, opacity .2s ease;
      display:inline-flex;align-items:center;gap:8px;white-space:nowrap;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:active{transform: translateY(1px) scale(.99)}
    .btn.primary{
      background: linear-gradient(180deg, rgba(124,77,255,.95), rgba(124,77,255,.55));
      border:1px solid rgba(124,77,255,.75);
      box-shadow: 0 12px 30px rgba(124,77,255,.22);
    }
    .btn.orange{
      background: linear-gradient(180deg, rgba(255,157,46,.95), rgba(255,157,46,.55));
      border:1px solid rgba(255,157,46,.75);
      box-shadow: 0 12px 30px rgba(255,157,46,.20);
    }
    .btn.disabled{opacity:.45; pointer-events:none;}
    .tonIcon{width:18px;height:18px;object-fit:contain;display:block;filter: drop-shadow(0 6px 14px rgba(0,0,0,.35));}
    .mono{font-variant-numeric: tabular-nums; font-feature-settings:"tnum" 1;}

    .grid{margin-top:12px;display:grid;grid-template-columns:1.2fr .8fr;gap:12px;}
    @media (max-width:860px){ .grid{grid-template-columns:1fr} .topbar{position:static} }

    .card{
      border-radius: var(--radius);
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
      overflow:hidden;
      position: relative;
    }

    #chart{
      height:360px;
      background: radial-gradient(900px 520px at 50% 0%, rgba(124,77,255,.30), rgba(124,77,255,.08) 45%, rgba(0,0,0,.10) 70%);
      position: relative;
    }

    /* убрать любые ссылки/вотермарки */
    #chart a, #chart [class*="watermark"], #chart [id*="watermark"]{display:none!important; opacity:0!important; pointer-events:none!important;}

    .loading{
      position:absolute; inset:0;
      z-index: 60;
      display:none;
      align-items:center; justify-content:center;
      background: radial-gradient(900px 520px at 50% 0%, rgba(124,77,255,.18), rgba(0,0,0,.25));
      backdrop-filter: blur(6px);
      font-weight:1100;
      letter-spacing:.2px;
      color: rgba(242,239,255,.92);
    }
    .loading.show{display:flex;}

    .endOrb{
      position:absolute;
      width:12px;height:12px;border-radius:999px;
      background: rgba(255,255,255,.92);
      transform: translate(-50%,-50%);
      pointer-events:none;
      z-index: 22;
      box-shadow:
        0 0 0 2px rgba(255,255,255,.28),
        0 0 18px rgba(255,255,255,.45),
        0 0 38px rgba(124,77,255,.22);
      filter: drop-shadow(0 12px 26px rgba(0,0,0,.55));
      display:none;
    }
    .endOrb::before{
      content:"";
      position:absolute; inset:-10px;
      border-radius:999px;
      background: radial-gradient(circle, rgba(255,255,255,.18), transparent 60%);
      animation: orbPulse 1.15s ease-in-out infinite;
    }
    @keyframes orbPulse{
      0%,100%{ transform: scale(0.85); opacity:.55; }
      50%{ transform: scale(1.05); opacity:.85; }
    }

    .countdown{
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%,-50%);
      width: 112px;
      height: 112px;
      display:none;
      place-items:center;
      z-index: 20;
      pointer-events:none;
      filter: drop-shadow(0 18px 45px rgba(0,0,0,.55));
    }
    .countdown.show{display:grid;}
    .cdNum{
      position:absolute;
      font-weight:1200;
      font-size:34px;
      letter-spacing:.2px;
      color: var(--text);
      text-shadow: 0 8px 30px rgba(0,0,0,.65);
    }
    .cdSub{
      position:absolute;
      bottom: 18px;
      font-size: 10px;
      color: rgba(242,239,255,.70);
      font-weight: 900;
      letter-spacing: .25px;
      text-transform: uppercase;
    }

    /* оверлей шкалы (скрыть цифры во время BET) */
    .scaleCover{
      position:absolute; top:0; right:0;
      width:86px; height:100%;
      background: linear-gradient(180deg, rgba(0,0,0,.10), rgba(0,0,0,.22));
      display:none;
      z-index: 19;
      pointer-events:none;
    }
    .scaleCover.show{display:block;}

    /* единственный бейдж значения справа */
    .valueBadge{
      position:absolute;
      right: 10px;
      top: 16px;
      z-index: 23;
      padding:6px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      backdrop-filter: blur(6px);
      font-weight:1100;
      font-size:12px;
      color: rgba(242,239,255,.95);
      pointer-events:none;
      box-shadow: 0 14px 35px rgba(0,0,0,.35);
    }

    .historyWrap{
      position:absolute;
      left:14px;
      bottom:14px;
      z-index: 25;
      pointer-events:none;
    }
    .histRow{
      display:flex;
      gap:6px;
      padding:8px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      backdrop-filter: blur(6px);
      box-shadow: 0 14px 35px rgba(0,0,0,.35);
      max-width: 520px;
      overflow:hidden;
    }
    .histItem{
      display:flex; align-items:center; gap:6px;
      font-weight:1000; font-size:11px;
      color: rgba(242,239,255,.92);
      white-space:nowrap;
    }
    .tri{
      width:0;height:0;
      border-left:7px solid transparent;
      border-right:7px solid transparent;
      position:relative;
      filter: drop-shadow(0 8px 18px rgba(0,0,0,.35));
    }
    .tri.up{ border-bottom: 12px solid var(--green); }
    .tri.down{ border-top: 12px solid var(--red); }
    .tri::after{
      content:"";
      position:absolute; left:-5px;
      width:0;height:0;
      border-left:5px solid transparent;
      border-right:5px solid transparent;
    }
    .tri.up::after{ top:2px; border-bottom: 9px solid rgba(255,255,255,.92); }
    .tri.down::after{ top:-11px; border-top: 9px solid rgba(255,255,255,.92); }
    .pctText{ min-width:52px; text-align:right; }

    .toast{
      position:absolute;
      right:14px;
      bottom:14px;
      z-index: 30;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      backdrop-filter: blur(8px);
      font-weight:1100;
      font-size:12px;
      display:none;
      pointer-events:none;
      box-shadow: 0 18px 45px rgba(0,0,0,.45);
    }
    .toast.show{display:block;}
    .toast.win{border-color: rgba(49,209,124,.35);}
    .toast.lose{border-color: rgba(255,77,77,.35);}

    .betWrap{padding:12px;}
    .amountGrid{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:10px;}
    .chip{
      padding:10px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);color:var(--text);font-weight:1000;font-size:12px;
      cursor:pointer;text-align:center;user-select:none;
    }
    .chip.active{
      border-color: rgba(255,157,46,.65);
      background: linear-gradient(180deg, rgba(255,157,46,.18), rgba(0,0,0,.18));
      box-shadow: 0 10px 25px rgba(255,157,46,.10);
    }
    .bigBox{
      padding:12px;border-radius:16px;border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);margin-bottom:10px;
    }
    .bigBox .label{font-size:11px;color:var(--muted);font-weight:900;text-transform:uppercase;letter-spacing:.25px}
    .bigBox .value{font-size:18px;font-weight:1150;margin-top:6px;display:flex;align-items:center;justify-content:space-between;gap:10px}
    .actions{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;}
    .btnLong{
      background: linear-gradient(180deg, rgba(49,209,124,.95), rgba(49,209,124,.50));
      border:1px solid rgba(49,209,124,.70);
      box-shadow: 0 14px 34px rgba(49,209,124,.18);
      justify-content:center;
    }
    .btnShort{
      background: linear-gradient(180deg, rgba(255,77,77,.95), rgba(255,77,77,.50));
      border:1px solid rgba(255,77,77,.70);
      box-shadow: 0 14px 34px rgba(255,77,77,.18);
      justify-content:center;
    }
    .hint{margin-top:10px;font-size:12px;color:var(--muted);line-height:1.35;min-height:34px;}

    .miniBtn{
      width:40px;height:40px;border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: var(--text);
      font-weight:1100;
      cursor:pointer;
      flex:0 0 auto;
    }
    .miniBtn:active{transform: translateY(1px) scale(.99)}
    .miniBtn.disabled{opacity:.45;pointer-events:none;}

    .modalOverlay{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      display:none;
      align-items:flex-end;
      justify-content:center;
      z-index:220;
      padding:14px;
    }
    .modalOverlay.open{ display:flex; }
    .sheet{
      width:min(560px, 100%);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(0,0,0,.22));
      box-shadow: 0 26px 90px rgba(0,0,0,.65);
      overflow:hidden;
    }
    .sheetHeader{
      padding:12px;
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    .sheetTitle{display:flex;align-items:center;gap:10px;font-weight:1100;letter-spacing:.3px;text-transform:uppercase;font-size:12px;}
    .sheetTitle img{width:22px;height:22px;border-radius:8px;}
    .closeBtn{
      width:42px;height:42px;border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: var(--text);
      cursor:pointer;font-weight:1100;
      user-select:none;
    }
    .sheetBtns{padding:12px;display:flex;flex-direction:column;gap:10px;}
    .sheetAction{
      height:54px;border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      box-shadow: 0 12px 26px rgba(0,0,0,.18);
      display:flex;align-items:center;justify-content:space-between;
      padding:0 14px;
      cursor:pointer;user-select:none;
      font-weight:1000;color:var(--text);
    }
    .sheetAction small{color:var(--muted);font-weight:900;}

    .depositInput{
      width:100%;height:52px;border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: var(--text);
      padding:0 14px;
      font-size:18px;font-weight:1000;
      outline:none;
    }
    .row2{display:flex;gap:10px;margin-top:12px;}
    .row2 .sheetAction{flex:1 1 0;justify-content:center;}

    /* Debug */
    .dbgBtn{
      position:fixed; right:12px; bottom:12px;
      z-index:9999; width:52px; height:52px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(242,239,255,.92);
      font-weight:1200;
      cursor:pointer;
      box-shadow: 0 18px 45px rgba(0,0,0,.55);
    }
    .dbgPanel{
      position:fixed; right:12px; bottom:72px;
      z-index:9999;
      width:min(520px, calc(100vw - 24px));
      max-height: 52vh;
      overflow:auto;
      display:none;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      box-shadow: 0 22px 60px rgba(0,0,0,.65);
      padding:10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      line-height:1.35;
      white-space: pre-wrap;
      color: rgba(242,239,255,.90);
    }
    .dbgPanel.show{display:block;}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand"><div class="logo"></div></div>
      <div class="rightbar">
        <button class="btn orange" id="btnTopup" type="button">Пополнить</button>
        <button class="btn primary" id="btnBalance" type="button">
          <img class="tonIcon" src="/ton.png" alt="TON" />
          <span>Баланс:</span>
          <span class="mono" id="balTon">0.00</span>
        </button>
      </div>
    </div>

    <div class="grid">
      <div class="card" id="chartCard">
        <div id="chart">
          <div class="loading" id="loading">Загрузка…</div>
          <div class="scaleCover" id="scaleCover"></div>
          <div class="valueBadge mono" id="valueBadge">0%</div>
          <div class="endOrb" id="endOrb"></div>
        </div>

        <div class="countdown" id="countdown">
          <svg width="112" height="112" viewBox="0 0 112 112">
            <defs>
              <filter id="glow">
                <feGaussianBlur stdDeviation="3.5" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            <circle cx="56" cy="56" r="46" stroke="rgba(255,255,255,.10)" stroke-width="10" fill="rgba(0,0,0,.20)"></circle>
            <circle id="cdRing" cx="56" cy="56" r="46" stroke="rgba(49,209,124,.95)" stroke-width="10" fill="transparent"
              stroke-linecap="round" transform="rotate(-90 56 56)"
              filter="url(#glow)"></circle>
          </svg>
          <div class="cdNum mono" id="cdNum">7</div>
          <div class="cdSub" id="cdSub">BET</div>
        </div>

        <div class="historyWrap">
          <div class="histRow" id="histRow"></div>
        </div>

        <div class="toast" id="toast"></div>
      </div>

      <div class="card">
        <div class="betWrap">
          <div class="amountGrid" id="chips">
            <div class="chip active" data-amt="0.1">0.10</div>
            <div class="chip" data-amt="0.2">0.20</div>
            <div class="chip" data-amt="0.5">0.50</div>
            <div class="chip" data-amt="1">1.00</div>
            <div class="chip" data-amt="2">2.00</div>
            <div class="chip" data-amt="5">5.00</div>
            <div class="chip" data-amt="10">10</div>
            <div class="chip" data-amt="20">20</div>
          </div>

          <div class="bigBox">
            <div class="label">Bet amount</div>
            <div class="value"><span class="mono" id="betAmt">0.10</span> TON</div>
          </div>

          <div class="bigBox">
            <div class="label">Your position</div>
            <div class="value mono">
              <span id="posStatus">—</span>
              <button class="miniBtn disabled" id="btnCancelBet" type="button" title="Отменить ставку">↩</button>
            </div>
          </div>

          <div class="actions">
            <button class="btn btnLong" id="btnLong" type="button">LONG ▲</button>
            <button class="btn btnShort" id="btnShort" type="button">SHORT ▼</button>
          </div>

          <div class="hint" id="hint"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Wallet modal -->
  <div class="modalOverlay" id="tonModal">
    <div class="sheet">
      <div class="sheetHeader">
        <div class="sheetTitle"><img src="/ton.png" alt="TON"> TON</div>
        <button class="closeBtn" id="tonClose" type="button">✕</button>
      </div>

      <div class="sheetBtns">
        <div class="sheetAction" id="actionBind">
          <span>Подключить кошелёк</span>
          <small id="walletStatus">Not connected</small>
        </div>
        <div class="sheetAction" id="actionDisconnect">
          <span>Отвязать кошелёк</span>
          <small>Disconnect</small>
        </div>
      </div>
    </div>
  </div>

  <!-- Deposit modal -->
  <div class="modalOverlay" id="depositModal">
    <div class="sheet">
      <div class="sheetHeader">
        <div class="sheetTitle">Пополнение</div>
        <button class="closeBtn" id="depositClose" type="button">✕</button>
      </div>

      <div style="padding:12px;">
        <input id="depositAmount" class="depositInput" type="number" min="0.1" step="0.1" placeholder="Сколько TON пополнить?">
        <div class="row2">
          <div class="sheetAction" id="depositBack">Назад</div>
          <div class="sheetAction" id="depositConfirm">Подтвердить</div>
        </div>
        <div class="hint" id="depositHint" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>

  <!-- Debug -->
  <button class="dbgBtn" id="dbgBtn" type="button">DBG</button>
  <div class="dbgPanel" id="dbgPanel"></div>

<script>
(function(){
  const $ = (id) => document.getElementById(id);

  // ===== Debug =====
  const dbgPanel = $("dbgPanel");
  const dbgBtn = $("dbgBtn");
  function dbg(msg){
    try{
      const t = new Date().toISOString().slice(11,19);
      dbgPanel.textContent = `[${t}] ${msg}\n` + dbgPanel.textContent;
    }catch{}
  }
  dbgBtn.addEventListener("click", () => dbgPanel.classList.toggle("show"));
  window.addEventListener("error", (e) => dbg("window.error: " + (e?.message || e)));
  window.addEventListener("unhandledrejection", (e) => dbg("unhandledrejection: " + (e?.reason?.message || e?.reason || e)));

  const tg = window.Telegram?.WebApp;
  try { tg?.ready?.(); tg?.expand?.(); } catch {}

  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function shortAddr(a){ return a ? (a.slice(0,6) + "..." + a.slice(-6)) : ""; }

  // ===== API =====
  const API_BASE = window.API_BASE || location.origin;
  const apiUrl = (path) => new URL(path, API_BASE).toString();

  async function apiGet(path){
    const r = await fetch(apiUrl(path), { cache:"no-store" });
    const txt = await r.text();
    let j = null;
    try{ j = JSON.parse(txt); }catch{ j = { raw: txt }; }
    if(!r.ok) throw new Error(path + " " + r.status + " " + (j?.error || j?.message || ""));
    return j;
  }
  async function apiPost(path, body){
    const r = await fetch(apiUrl(path), {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body || {})
    });
    const txt = await r.text();
    let j = null;
    try{ j = JSON.parse(txt); }catch{ j = { raw: txt }; }
    if(!r.ok) throw new Error(path + " " + r.status + " " + (j?.error || j?.message || ""));
    return j;
  }

  function setHint(t){
    const el = $("hint");
    if (el) el.textContent = t || "";
  }
  function setSafeError(msg){
    setHint(msg);
    dbg(msg);
    console.warn(msg);
  }

  const toast = $("toast");
  let toastTimer = null;
  function showToast(kind, text){
    if(!toast) return;
    toast.className = "toast show " + (kind || "");
    toast.textContent = text;
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => {
      toast.className = "toast";
      toast.textContent = "";
    }, 1700);
  }

  // ===== UI =====
  const loading = $("loading");
  const scaleCover = $("scaleCover");
  const valueBadge = $("valueBadge");
  const endOrb = $("endOrb");

  // chips
  let selectedAmt = 0.10;
  $("chips")?.addEventListener("click", (e) => {
    const chip = e.target.closest(".chip");
    if(!chip) return;
    document.querySelectorAll(".chip").forEach(c => c.classList.remove("active"));
    chip.classList.add("active");
    selectedAmt = Number(chip.dataset.amt || "0.1");
    $("betAmt").textContent = selectedAmt.toFixed(2);
  });

  // ===== Countdown =====
  const cdEl = $("countdown");
  const cdNumEl = $("cdNum");
  const cdSubEl = $("cdSub");
  const cdRingEl = $("cdRing");
  const R = 46;
  const CIRC = 2 * Math.PI * R;
  if (cdRingEl){
    cdRingEl.setAttribute("stroke-dasharray", String(CIRC));
    cdRingEl.setAttribute("stroke-dashoffset", "0");
  }
  function setRing(progress01){
    if(!cdRingEl) return;
    const off = CIRC * (1 - Math.max(0, Math.min(1, progress01)));
    cdRingEl.setAttribute("stroke-dashoffset", String(off));
  }
  function setRingColor(secLeft){
    if(!cdRingEl) return;
    if (secLeft >= 5) cdRingEl.setAttribute("stroke", "rgba(49,209,124,.95)");
    else if (secLeft >= 3) cdRingEl.setAttribute("stroke", "rgba(255,204,51,.95)");
    else cdRingEl.setAttribute("stroke", "rgba(255,77,77,.95)");
  }

  // ===== Server time offset =====
  let timeOffsetMs = 0;
  function serverNow(){ return Date.now() + timeOffsetMs; }

  // ===== History (ТОЛЬКО сервер) =====
  function renderHistory(serverItems){
    const row = $("histRow");
    if(!row) return;
    row.innerHTML = "";
    const arr = Array.isArray(serverItems) ? serverItems : [];

    if (!arr.length) {
      const wrap = document.createElement("div");
      wrap.className = "histItem";
      wrap.style.opacity = "0.75";
      wrap.textContent = "История пустая (сервер не отдаёт history)";
      row.appendChild(wrap);
      return;
    }

    for (const it of arr.slice(0, 10)) {
      const pct = Number(it?.pct ?? it?.endPct ?? it?.resultPct ?? it?.value ?? 0);
      const wrap = document.createElement("div");
      wrap.className = "histItem";

      const tri = document.createElement("div");
      tri.className = "tri " + (pct >= 0 ? "up" : "down");

      const txt = document.createElement("div");
      txt.className = "pctText mono";
      txt.textContent = (pct > 0 ? "+" : "") + String(Math.round(pct)) + "%";

      wrap.appendChild(tri);
      wrap.appendChild(txt);
      row.appendChild(wrap);
    }
  }

  // ===== Chart =====
  let chart=null, area=null, bound=null;

  const MIN_Y = -100;
  const MAX_Y = 200;

  // камера
  let camCenter = 0;
  const CAM_WINDOW = 60;
  const CAM_EASE = 0.08;

  // данные анимации
  let points = [];          // [{time, value}] time in seconds
  let baseData = [];        // уже добавленные точки
  let idx = 0;              // индекс следующей точки
  let cur = 0;              // текущее значение
  let running = false;
  let rafId = 0;

  function applySeriesColorByValue(v){
    const isGreen = (Number(v) >= 0);
    const line = isGreen ? "rgba(49,209,124,.95)" : "rgba(255,77,77,.95)";
    const top  = isGreen ? "rgba(49,209,124,.26)" : "rgba(255,77,77,.22)";
    try{ area.applyOptions({ lineColor: line, topColor: top, bottomColor: "rgba(0,0,0,0)" }); }catch{}
  }

  function ensureBoundNow(v, tSec){
    if(!bound) return;
    camCenter = camCenter + (v - camCenter) * CAM_EASE;
    const lo = clamp(camCenter - CAM_WINDOW, MIN_Y, MAX_Y);
    const hi = clamp(camCenter + CAM_WINDOW, MIN_Y, MAX_Y);
    const tt = tSec ?? (points[idx-1]?.time ?? Math.floor(Date.now()/1000));
    try{ bound.setData([{ time: tt-1, value: lo }, { time: tt, value: hi }]); }catch{}
  }

  function updateValueBadge(){
    const v = Math.round(Number(cur) || 0);
    valueBadge.textContent = (v > 0 ? "+" : "") + v + "%";
  }

  function placeOrb(timeSec, value){
    try{
      if(!chart || !area || !endOrb) return;
      const x = chart.timeScale().timeToCoordinate(timeSec);
      const y = area.priceToCoordinate(value);
      if (x == null || y == null) return;
      endOrb.style.left = x + "px";
      endOrb.style.top  = y + "px";
      endOrb.style.display = "block";
    }catch{}
  }

  function initChart(){
    const el = $("chart");
    if(!el || !window.LightweightCharts?.createChart) return false;

    chart = LightweightCharts.createChart(el, {
      width: Math.max(320, el.clientWidth || 900),
      height: 360,
      layout: { background: { type:"solid", color:"transparent" }, textColor: "rgba(242,239,255,.55)" },
      grid: { vertLines: { color: "rgba(255,255,255,.04)" }, horzLines: { color: "rgba(255,255,255,.05)" } },
      rightPriceScale: {
        visible: true,
        borderColor: "rgba(255,255,255,.10)",
        scaleMargins: { top: 0.10, bottom: 0.12 }
      },
      timeScale: { borderColor: "rgba(255,255,255,.10)", timeVisible:false, secondsVisible:true },
      crosshair: { vertLine: { visible:false }, horzLine: { visible:false } },
      watermark: { visible: false }
    });

    const curved =
      window.LightweightCharts &&
      window.LightweightCharts.LineType &&
      window.LightweightCharts.LineType.Curved;

    area = chart.addAreaSeries({
      lineWidth: 2,
      lineType: curved ? window.LightweightCharts.LineType.Curved : undefined,
      lineColor: "rgba(49,209,124,.95)",
      topColor: "rgba(49,209,124,.26)",
      bottomColor: "rgba(0,0,0,0)",
      priceFormat: { type:"custom", formatter: (v) => `${Math.round(Number(v))}%` },
      priceLineVisible: false,
      lastValueVisible: false
    });

    bound = chart.addLineSeries({
      color: "rgba(0,0,0,0)",
      lineWidth: 1,
      lastValueVisible: false,
      priceLineVisible: false
    });

    const ro = new ResizeObserver(() => {
      try{ chart.resize(Math.max(320, el.clientWidth || 900), 360); }catch{}
    });
    ro.observe(el);

    return true;
  }

  // ===== series processing (ms/sec -> sec, downsample, smooth) =====
  function toSec(x){
    const n = Number(x);
    if (!Number.isFinite(n)) return null;
    return n > 3e10 ? Math.floor(n / 1000) : Math.floor(n);
  }

  function downsample(arr, maxPoints){
    if (arr.length <= maxPoints) return arr;
    const step = Math.ceil(arr.length / maxPoints);
    const out = [];
    for (let i=0;i<arr.length;i+=step) out.push(arr[i]);
    if (out[out.length-1].time !== arr[arr.length-1].time) out.push(arr[arr.length-1]);
    return out;
  }

  function smoothValues(arr){
    const alpha = 0.16; // меньше дрожи
    let prev = arr[0]?.value ?? 0;
    const out = [];
    for (let i=0;i<arr.length;i++){
      const v = arr[i].value;
      const sv = i===0 ? v : (prev + alpha*(v - prev));
      prev = sv;
      out.push({ time: arr[i].time, value: sv });
    }
    if (out.length >= 2) out[out.length-1].value = arr[arr.length-1].value;
    return out;
  }

  function setNewSeries(rawSeries){
    let arr = [];
    for (const p of (rawSeries || [])){
      if (!Array.isArray(p) || p.length < 2) continue;
      const tSec = toSec(p[0]);
      const v = Number(p[1]);
      if (tSec == null || !Number.isFinite(v)) continue;
      arr.push({ time: tSec, value: clamp(v, MIN_Y, MAX_Y) });
    }
    if (!arr.length) {
      const nowS = Math.floor(Date.now()/1000);
      arr = [{ time: nowS, value: 0 }, { time: nowS+1, value: 0 }];
    }

    arr = downsample(arr, 240);
    arr = smoothValues(arr);

    points = arr;
    baseData = [points[0]];
    idx = 1;
    cur = points[0].value;

    try{ area.setData(baseData); }catch{}
    applySeriesColorByValue(cur);
    ensureBoundNow(cur, points[0].time);
    updateValueBadge();
    placeOrb(points[0].time, cur);

    try{
      const from = points[0].time;
      const to = points[Math.min(points.length-1, 40)].time;
      chart.timeScale().setVisibleRange({ from, to });
    }catch{}
  }

  // ===== 60fps animation =====
  function stopAnim(){
    running = false;
    if (rafId) cancelAnimationFrame(rafId);
    rafId = 0;
  }

  function startAnim(){
    stopAnim();
    running = true;

    const tick = () => {
      if (!running) return;

      const nowSec = Math.floor(serverNow()/1000);

      while (idx < points.length && points[idx].time <= nowSec) {
        baseData.push(points[idx]);
        try{ area.update(points[idx]); }catch{}
        idx++;
      }

      const last = baseData[baseData.length - 1];
      const next = points[idx] || last;

      let v = last.value;
      if (next && next.time > last.time) {
        const p = clamp((nowSec - last.time) / (next.time - last.time), 0, 1);
        v = last.value + (next.value - last.value) * p;
      }
      cur = clamp(v, MIN_Y, MAX_Y);

      try{ area.update({ time: nowSec, value: cur }); }catch{}
      applySeriesColorByValue(cur);
      ensureBoundNow(cur, nowSec);
      updateValueBadge();
      placeOrb(nowSec, cur);

      try{
        const from = Math.max(points[0].time, nowSec - 60);
        const to = nowSec + 6;
        chart.timeScale().setVisibleRange({ from, to });
      }catch{}

      rafId = requestAnimationFrame(tick);
    };

    rafId = requestAnimationFrame(tick);
  }

  // ===== Betting window / state =====
  let lastState = null;
  let currentRound = null;
  let betMs = 7000;
  let lastPhase = null;
  let bettingOpen = false;
  let pos = null;
  let lastSettledRound = null;

  function getBetWindowFromState(s){
    const now = serverNow();
    const phase = s?.phase;
    const phaseEndsAt = Number(s?.phaseEndsAt);
    if (phase && Number.isFinite(phaseEndsAt)) {
      const inBet = (phase === "BET");
      const leftMs = Math.max(0, phaseEndsAt - now);
      return { inBet, leftMs, betMs: Number(s?.betMs || betMs), phase };
    }
    return { inBet:false, leftMs:0, betMs, phase:"PLAY" };
  }

  function setPosStatus(){
    $("posStatus").textContent = pos ? `${String(pos.side).toUpperCase()} • ${pos.amount.toFixed(2)} TON` : "—";
    $("btnCancelBet").classList.toggle("disabled", !(pos && bettingOpen));
  }

  function updateCountdownAndButtons(state){
    const s = state || lastState || {};
    if(!currentRound) return;

    const w = getBetWindowFromState(s);
    const inBet = !!w.inBet;
    const leftMs = Number(w.leftMs || 0);
    const betWindowMs = Number(w.betMs || betMs);
    const phase = w.phase || s.phase || null;

    scaleCover.classList.toggle("show", inBet);

    // BET -> PLAY: перезагружаем серию нового раунда и стартуем с 0 визуально (серия сама с нуля)
    if (lastPhase === "BET" && phase === "PLAY") {
      bootSeriesForCurrentRound("phase_change").catch(()=>{});
    }
    lastPhase = phase;

    bettingOpen = inBet && !!getWalletRawLS();
    $("btnLong").classList.toggle("disabled", !bettingOpen);
    $("btnShort").classList.toggle("disabled", !bettingOpen);

    if (inBet){
      const secLeft = Math.max(0, Math.ceil(leftMs/1000));
      cdEl.classList.add("show");
      cdNumEl.textContent = String(secLeft);
      cdSubEl.textContent = "BET";
      setRing(betWindowMs > 0 ? (leftMs / betWindowMs) : 0);
      setRingColor(secLeft);

      if(!getWalletRawLS()) setHint("Подключи кошелёк, чтобы делать ставки.");
      else setHint("");
    } else {
      cdEl.classList.remove("show");
      cdSubEl.textContent = "PLAY";
      setHint("");
    }

    $("btnCancelBet").classList.toggle("disabled", !(pos && inBet && !!getWalletRawLS()));
  }

  // ===== Wallet (TonConnect) =====
  let __tonCore = null;
  async function tonCore(){
    if (!__tonCore) __tonCore = await import("https://esm.sh/@ton/core@0.58.0");
    return __tonCore;
  }

  function getWalletRawLS(){
    const ls = (localStorage.getItem("walletRaw") || "").trim();
    return ls || null;
  }
  async function setWalletFromTonConnect(wallet){
    const addr = (wallet?.account?.address || "").trim();
    if (!addr){
      localStorage.removeItem("walletRaw");
      localStorage.removeItem("walletFriendly");
      return;
    }
    const { Address } = await tonCore();
    const raw = Address.parse(addr).toRawString();
    localStorage.setItem("walletRaw", raw);
    const fr = Address.parse(raw).toString({ urlSafe: true, bounceable: false, testOnly: false });
    localStorage.setItem("walletFriendly", fr);
  }
  async function getWalletFriendlyLS(){
    const cached = (localStorage.getItem("walletFriendly") || "").trim();
    if (cached) return cached;
    const raw = getWalletRawLS();
    if (!raw) return null;
    const { Address } = await tonCore();
    const fr = Address.parse(raw).toString({ urlSafe: true, bounceable: false, testOnly: false });
    localStorage.setItem("walletFriendly", fr);
    return fr;
  }

  (function initTonConnect(){
    try{
      const TonConnectUI = window.TON_CONNECT_UI?.TonConnectUI;
      if (!TonConnectUI) { window.__tonUI = null; window.__wallet = null; return; }

      const tonUI = new TonConnectUI({
        manifestUrl: location.origin + "/tonconnect-manifest.json",
        uiPreferences: { theme: "DARK" },
        actionsConfiguration: { twaReturnUrl: (window.__TWA_RETURN_URL || location.href) }
      });

      window.__tonUI = tonUI;
      window.__wallet = null;

      tonUI.onStatusChange(async (wallet) => {
        window.__wallet = wallet || null;
        try{ await setWalletFromTonConnect(wallet); }catch{
          localStorage.removeItem("walletRaw");
          localStorage.removeItem("walletFriendly");
        }
        window.dispatchEvent(new Event("wallet_changed"));
      });

      tonUI.connectionRestored
        .then(() => window.dispatchEvent(new Event("wallet_changed")))
        .catch(() => {});
    }catch(e){
      dbg("TonConnect init error: " + (e?.message || e));
      window.__tonUI = null;
      window.__wallet = null;
    }
  })();

  const tonModal = $("tonModal");
  function openTonModal(){ tonModal?.classList.add("open"); }
  function closeTonModal(){ tonModal?.classList.remove("open"); }

  $("btnBalance")?.addEventListener("click", openTonModal);
  $("tonClose")?.addEventListener("click", closeTonModal);
  tonModal?.addEventListener("click", (e) => { if(e.target === tonModal) closeTonModal(); });

  $("actionBind")?.addEventListener("click", async () => {
    try{
      if (window.__tonUI?.openModal) { await window.__tonUI.openModal(); return; }
      alert("TonConnect не загрузился.");
    }catch(e){
      alert("Ошибка подключения: " + String(e?.message || e));
    }
  });

  $("actionDisconnect")?.addEventListener("click", async () => {
    try{ await window.__tonUI?.disconnect?.(); }catch{}
    localStorage.removeItem("walletRaw");
    localStorage.removeItem("walletFriendly");
    window.__wallet = null;
    window.dispatchEvent(new Event("wallet_changed"));
  });

  async function syncWalletUI(){
    const raw = getWalletRawLS();
    const walletStatus = $("walletStatus");
    if (!walletStatus) return;
    if (!raw){ walletStatus.textContent = "Not connected"; return; }
    const fr = await getWalletFriendlyLS();
    walletStatus.textContent = shortAddr(fr || raw);
  }

  function setBalanceTonUI(v){
    const ton = Number(v) || 0;
    const el = $("balTon");
    if (el) el.textContent = ton.toFixed(2);
  }

  async function refreshBalance(){
    const raw = getWalletRawLS();
    if (!raw){ setBalanceTonUI(0); return 0; }
    try{
      const r = await fetch(apiUrl(`/api/balance?address=${encodeURIComponent(raw)}&t=${Date.now()}`), { cache:"no-store" });
      const j = await r.json().catch(()=>({}));
      const ton = Number(j.balanceTon ?? j.ton ?? 0);
      if (Number.isFinite(ton)) setBalanceTonUI(ton);
      return ton;
    }catch{ return 0; }
  }

  window.addEventListener("wallet_changed", async () => {
    await syncWalletUI().catch(()=>{});
    await refreshBalance().catch(()=>{});
    updateCountdownAndButtons();
  });

  // ===== Deposit modal (минимально) =====
  const depositModal = $("depositModal");
  function openDepositModal(){ depositModal?.classList.add("open"); }
  function closeDepositModal(){ depositModal?.classList.remove("open"); }

  $("btnTopup")?.addEventListener("click", () => {
    if(!getWalletRawLS()){ openTonModal(); alert("Сначала подключи кошелёк."); return; }
    $("depositHint").textContent = "";
    $("depositAmount").value = "";
    openDepositModal();
  });
  $("depositClose")?.addEventListener("click", closeDepositModal);
  $("depositBack")?.addEventListener("click", closeDepositModal);
  depositModal?.addEventListener("click", (e) => { if(e.target === depositModal) closeDepositModal(); });

  // ===== Bets =====
  async function place(side){
    if(!bettingOpen) return;
    const raw = getWalletRawLS();
    if(!raw){ openTonModal(); return; }

    try{
      await apiPost("/api/bet_place?t=" + Date.now(), {
        side,
        amountTon: selectedAmt,
        roundId: currentRound?.roundId,
        address: raw
      });

      pos = { side, amount: selectedAmt, roundId: currentRound?.roundId };
      setPosStatus();
      setHint("Ставка принята");
      await refreshBalance().catch(()=>{});
    }catch(e){
      setHint("Ошибка ставки: " + String(e?.message || e));
      dbg("bet_place error: " + String(e?.message || e));
    }
  }

  $("btnLong").addEventListener("click", () => place("long"));
  $("btnShort").addEventListener("click", () => place("short"));

  $("btnCancelBet").addEventListener("click", async () => {
    if (!pos || !currentRound) return;
    const raw = getWalletRawLS();
    if(!raw) { openTonModal(); return; }

    try{
      await apiPost("/api/bet_cancel?t=" + Date.now(), { address: raw, roundId: pos.roundId });
      pos = null;
      setPosStatus();
      setHint("Ставка отменена");
      await refreshBalance().catch(()=>{});
    }catch(e){
      setHint("Не удалось отменить: " + String(e?.message || e));
      dbg("bet_cancel error: " + String(e?.message || e));
    }
  });

  async function trySettleIfNeeded(){
    if(!pos || !currentRound) return;

    const now = serverNow();
    const nextAt = Number(currentRound?.nextAt);
    if (Number.isFinite(nextAt) && now < nextAt) return;

    if (lastSettledRound === pos.roundId) return;

    const raw = getWalletRawLS();
    if(!raw) return;

    try{
      const r = await apiPost("/api/bet_settle?t=" + Date.now(), { address: raw, roundId: pos.roundId });
      if (r?.status === "pending" || r?.status === "already_settled") return;

      lastSettledRound = pos.roundId;
      await refreshBalance().catch(()=>{});

      const pct = Number(r.pct);
      const sPct = (pct > 0 ? "+" : "") + String(Math.round(pct)) + "%";
      const profit = Number(r.profitTon || 0);

      showToast(profit >= 0 ? "win" : "lose", (profit >= 0 ? "WIN " : "LOSE ") + sPct);

      // подтянуть серверную историю сразу
      await loadState().catch(()=>{});

      pos = null;
      setPosStatus();
      setHint("");
    }catch(e){}
  }

  // ===== State / Series sync =====
  async function loadState(){
    const s = await apiGet("/api/state?t=" + Date.now());
    lastState = s;

    timeOffsetMs = (s.serverNow || Date.now()) - Date.now();
    currentRound = s.round || null;
    betMs = s.betMs || betMs;

    renderHistory(s.history || []);

    dbg("state: " + JSON.stringify({ phase:s?.phase, roundId:s?.round?.roundId, hist:(s?.history?.length||0) }));
    updateCountdownAndButtons(s);

    return s;
  }

  let lastLoadedRoundId = null;

  // ВАЖНО: серия грузится ТОЛЬКО по roundId из state, иначе рассинхрон
  async function bootSeriesForCurrentRound(reason){
    try{
      loading.classList.add("show");

      const rid = Number(currentRound?.roundId);
      if (!Number.isFinite(rid)) throw new Error("no_roundId_in_state");

      // не перезагружать одно и то же каждые 4 сек
      if (lastLoadedRoundId === rid && reason !== "force") {
        loading.classList.remove("show");
        return;
      }

      const x = await apiGet("/api/series?roundId=" + encodeURIComponent(String(rid)) + "&t=" + Date.now());
      dbg("series: " + JSON.stringify({ want: rid, roundId:x?.roundId, len:(x?.series?.length||0), endPct:x?.endPct }));

      // защита: если бек отдал не тот roundId — НЕ принимаем
      if (Number(x?.roundId) !== rid) throw new Error("series_roundId_mismatch want=" + rid + " got=" + x?.roundId);

      setNewSeries(x?.series || []);
      startAnim();
      lastLoadedRoundId = rid;
    }catch(e){
      dbg("bootSeries error: " + (e?.message || e));
    } finally {
      loading.classList.remove("show");
    }
  }

  // ===== Boot =====
  (async function boot(){
    try{
      if(!initChart()){
        setSafeError("Chart init failed (LightweightCharts).");
        return;
      }

      setPosStatus();
      setHint("");

      await syncWalletUI().catch(()=>{});
      await refreshBalance().catch(()=>{});

      await loadState().catch(e => setSafeError("STATE error: " + (e?.message || e)));
      await bootSeriesForCurrentRound("force"); // сразу грузим серию текущего раунда

      // опросы не душим (чтоб не лагало)
      setInterval(() => loadState().catch(()=>{}), 1200);
      setInterval(() => updateCountdownAndButtons(), 160);
      setInterval(() => trySettleIfNeeded(), 800);
      setInterval(() => refreshBalance().catch(()=>{}), 8000);

      // проверяем смену раунда раз в 2.5 сек (и только тогда грузим серию заново)
      setInterval(async () => {
        try{
          const s = await loadState();
          const rid = Number(s?.round?.roundId);
          if (Number.isFinite(rid) && rid !== lastLoadedRoundId) {
            await bootSeriesForCurrentRound("force");
          }
        }catch{}
      }, 2500);

    }catch(e){
      setSafeError("Boot error: " + String(e?.message || e));
    }
  })();

})();
</script>
</body>
</html>
